What happens when you initialize a repository? Why do you need to do it?

	When a repository is initialized with command "git init" a hiden folder
	called .git is created, in it is stored all the information about the
	the history of the documents that there are in the parent folder of .git.

How is the staging area different from the working directory and the repository? 
What value do you think it offers?
	
	The staging area is the area when are placed the files that we want git to track.
	the working directory may have a lot of others files that we use for testing
	or just for play with the program but the staging area contains the files that
	are really important to the project and we want to make a history of them.

How can you use the staging area to make sure you have one commit per logical change?

	The staging area must be used to put in there every change that we have made to the
	files in the working directory and then commit that changes to the repository, so, 
	if I am changing various related files, becacuse all of them are related to a 
	function (or single unit) I can put all those changes to the staging area
	and commit all changes at once. Even if I was working on different files that may not
	be related to a single unit I then just don't send that changes to the staging area
	so those changes will not be on the commit.

What are some situations when branches would be helpful in keeping your history organized?
How would branches help?

	When you are triying something new, or different at the original idea, or you just 
	are making some practices to see what happens, it is usefull to use branches
	so you could make anything without worriying about the consecuenses to the main
	project and if you succed with whatever you whant to achive, then you can release
	at another project. Or maybe merge your ideas with the original ones.

How do the diagrams help you visualize the branch structure?
	
	The diagrams are very helpfull because they are simple "graphic" forms to see
	the different branches and commits in each one, and how are they related
	or how are they different. so we have a high level view of all the features
	we have been working on separately.

What is the result of merging two branches together? Why do we represent it in the diagram the way we do?

	the result of merge branches is that the result will integrate the changes from both branches,
	so if someone is working in funcition A and your partner is working on function B
	when you merge the branches you will get both functions in the result.
	they are well represented like a graph, because each commit is like a node that a state of the code.
	and when you merge two branches you get that two nodes fusion their content to get a more complete version
	which is represented as another state or node in the graph.

What are the pros and cons of Gitâ€™s automatic merging vs. always doing merges manually?

	the pros of automatic merging is that you spend less time revising and comparing different versions.
	and you get a reasonable result, the cons is that you have no control of the place where the code
	will end, and you must trust the version control sistem to do it well for you. Something difficult.
	When you do manual merge two files or two commits, you have to spend a lot of time reviewing those files
	and deciding what to preserve and what to delete, and talking to your partners. and testing again and
	again if the program still runs like it is suposed to do.